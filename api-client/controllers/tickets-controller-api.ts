/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ChangeTicketHeadRequest } from '../models';
// @ts-ignore
import { ChangeTicketStateRequest } from '../models';
// @ts-ignore
import { ChangeTicketStateResponse } from '../models';
// @ts-ignore
import { CreateBlacklistRecordRequest } from '../models';
// @ts-ignore
import { CreateTicketRequest } from '../models';
// @ts-ignore
import { HelperStats } from '../models';
// @ts-ignore
import { HelperStatsRequest } from '../models';
// @ts-ignore
import { HelpersStatsRequest } from '../models';
// @ts-ignore
import { PredefinedMessage } from '../models';
// @ts-ignore
import { PredefinedMessageRequest } from '../models';
// @ts-ignore
import { RateTicketRequest } from '../models';
// @ts-ignore
import { ResponsePageTicketBlacklistDTO } from '../models';
// @ts-ignore
import { ResponsePageTicketInfo } from '../models';
// @ts-ignore
import { ResultResponse } from '../models';
// @ts-ignore
import { SendTicketMessageRequest } from '../models';
// @ts-ignore
import { SetDuplicateResponse } from '../models';
// @ts-ignore
import { SetStarRequest } from '../models';
// @ts-ignore
import { SetTicketNoteRequest } from '../models';
// @ts-ignore
import { TicketBlacklist } from '../models';
// @ts-ignore
import { TicketDTO } from '../models';
// @ts-ignore
import { TicketFilters } from '../models';
// @ts-ignore
import { TicketMessageDTO } from '../models';
// @ts-ignore
import { TicketRating } from '../models';
// @ts-ignore
import { TicketType } from '../models';
/**
 * TicketsControllerApi - axios parameter creator
 * @export
 */
export const TicketsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToBlacklist: async (createBlacklistRecordRequest: CreateBlacklistRecordRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createBlacklistRecordRequest' is not null or undefined
            assertParamExists('addUserToBlacklist', 'createBlacklistRecordRequest', createBlacklistRecordRequest)
            const localVarPath = `/tickets/blacklist`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createBlacklistRecordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeTicketByUid: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('closeTicketByUid', 'uid', uid)
            const localVarPath = `/tickets/{uid}/close`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPredefinedMessage: async (uuid: string, predefinedMessageRequest: PredefinedMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('createPredefinedMessage', 'uuid', uuid)
            // verify required parameter 'predefinedMessageRequest' is not null or undefined
            assertParamExists('createPredefinedMessage', 'predefinedMessageRequest', predefinedMessageRequest)
            const localVarPath = `/tickets/user/{uuid}/predefinedmessages`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predefinedMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket: async (createTicketRequest: CreateTicketRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTicketRequest' is not null or undefined
            assertParamExists('createTicket', 'createTicketRequest', createTicketRequest)
            const localVarPath = `/tickets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTicketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage: async (uid: string, messageUid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteMessage', 'uid', uid)
            // verify required parameter 'messageUid' is not null or undefined
            assertParamExists('deleteMessage', 'messageUid', messageUid)
            const localVarPath = `/tickets/{uid}/message/{messageUid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"messageUid"}}`, encodeURIComponent(String(messageUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePredefinedMessage: async (uuid: string, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deletePredefinedMessage', 'uuid', uuid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePredefinedMessage', 'id', id)
            const localVarPath = `/tickets/user/{uuid}/predefinedmessages/{id}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage: async (uid: string, messageUid: string, sendTicketMessageRequest: SendTicketMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('editMessage', 'uid', uid)
            // verify required parameter 'messageUid' is not null or undefined
            assertParamExists('editMessage', 'messageUid', messageUid)
            // verify required parameter 'sendTicketMessageRequest' is not null or undefined
            assertParamExists('editMessage', 'sendTicketMessageRequest', sendTicketMessageRequest)
            const localVarPath = `/tickets/{uid}/message/{messageUid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"messageUid"}}`, encodeURIComponent(String(messageUid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTicketMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklist: async (page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getBlacklist', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getBlacklist', 'perPage', perPage)
            const localVarPath = `/tickets/blacklist/{page}/{perPage}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {HelperStatsRequest} helperStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelperStats: async (uuid: string, helperStatsRequest: HelperStatsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getHelperStats', 'uuid', uuid)
            // verify required parameter 'helperStatsRequest' is not null or undefined
            assertParamExists('getHelperStats', 'helperStatsRequest', helperStatsRequest)
            const localVarPath = `/tickets/user/{uuid}/stats`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helperStatsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {HelpersStatsRequest} helpersStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpersStats: async (helpersStatsRequest: HelpersStatsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'helpersStatsRequest' is not null or undefined
            assertParamExists('getHelpersStats', 'helpersStatsRequest', helpersStatsRequest)
            const localVarPath = `/tickets/users/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(helpersStatsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPredefinedMessages: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getPredefinedMessages', 'uuid', uuid)
            const localVarPath = `/tickets/user/{uuid}/predefinedmessages`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatings: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getRatings', 'uuid', uuid)
            const localVarPath = `/tickets/user/{uuid}/rating`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketAttachment: async (uid: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getTicketAttachment', 'uid', uid)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getTicketAttachment', 'fileName', fileName)
            const localVarPath = `/tickets/{uid}/attachments/{fileName}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketByUid: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getTicketByUid', 'uid', uid)
            const localVarPath = `/tickets/{uid}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketMessageAttachment: async (uid: string, messageUuid: string, fileName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getTicketMessageAttachment', 'uid', uid)
            // verify required parameter 'messageUuid' is not null or undefined
            assertParamExists('getTicketMessageAttachment', 'messageUuid', messageUuid)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getTicketMessageAttachment', 'fileName', fileName)
            const localVarPath = `/tickets/{uid}/message/{messageUuid}/attachments/{fileName}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"messageUuid"}}`, encodeURIComponent(String(messageUuid)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tickets/types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {TicketFilters} [ticketFilters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets: async (page: number, perPage: number, sortBy?: string, sortDirection?: string, ticketFilters?: TicketFilters, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getTickets', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getTickets', 'perPage', perPage)
            const localVarPath = `/tickets/all/{page}/{perPage}`
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ticketFilters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTicketsByUserUuid: async (uuid: string, page: number, perPage: number, sortBy?: string, sortDirection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getUserTicketsByUserUuid', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getUserTicketsByUserUuid', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getUserTicketsByUserUuid', 'perPage', perPage)
            const localVarPath = `/tickets/user/{uuid}/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDirection !== undefined) {
                localVarQueryParameter['sortDirection'] = sortDirection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserBlacklisted: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('isUserBlacklisted', 'uuid', uuid)
            const localVarPath = `/tickets/blacklist/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage: async (uid: string, sendTicketMessageRequest: SendTicketMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('postMessage', 'uid', uid)
            // verify required parameter 'sendTicketMessageRequest' is not null or undefined
            assertParamExists('postMessage', 'sendTicketMessageRequest', sendTicketMessageRequest)
            const localVarPath = `/tickets/{uid}/message`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendTicketMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {RateTicketRequest} rateTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateTicketByUid: async (uid: string, rateTicketRequest: RateTicketRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('rateTicketByUid', 'uid', uid)
            // verify required parameter 'rateTicketRequest' is not null or undefined
            assertParamExists('rateTicketByUid', 'rateTicketRequest', rateTicketRequest)
            const localVarPath = `/tickets/{uid}/rate`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateTicketRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBlacklistRecord: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeBlacklistRecord', 'id', id)
            const localVarPath = `/tickets/blacklist/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reopenTicketByUid: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('reopenTicketByUid', 'uid', uid)
            const localVarPath = `/tickets/{uid}/reopen`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardCoins: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('rewardCoins', 'uid', uid)
            const localVarPath = `/tickets/{uid}/rewardcoins`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketDuplicate: async (uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setTicketDuplicate', 'uid', uid)
            const localVarPath = `/tickets/{uid}/duplicate`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketHeadRequest} changeTicketHeadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketHead: async (uid: string, changeTicketHeadRequest: ChangeTicketHeadRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setTicketHead', 'uid', uid)
            // verify required parameter 'changeTicketHeadRequest' is not null or undefined
            assertParamExists('setTicketHead', 'changeTicketHeadRequest', changeTicketHeadRequest)
            const localVarPath = `/tickets/{uid}/head`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTicketHeadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetTicketNoteRequest} setTicketNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketNote: async (uid: string, setTicketNoteRequest: SetTicketNoteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setTicketNote', 'uid', uid)
            // verify required parameter 'setTicketNoteRequest' is not null or undefined
            assertParamExists('setTicketNote', 'setTicketNoteRequest', setTicketNoteRequest)
            const localVarPath = `/tickets/{uid}/note`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setTicketNoteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetStarRequest} setStarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketStar: async (uid: string, setStarRequest: SetStarRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setTicketStar', 'uid', uid)
            // verify required parameter 'setStarRequest' is not null or undefined
            assertParamExists('setTicketStar', 'setStarRequest', setStarRequest)
            const localVarPath = `/tickets/{uid}/star`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setStarRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketStateRequest} changeTicketStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketState: async (uid: string, changeTicketStateRequest: ChangeTicketStateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('setTicketState', 'uid', uid)
            // verify required parameter 'changeTicketStateRequest' is not null or undefined
            assertParamExists('setTicketState', 'changeTicketStateRequest', changeTicketStateRequest)
            const localVarPath = `/tickets/{uid}/state`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeTicketStateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePredefinedMessage: async (uuid: string, id: number, predefinedMessageRequest: PredefinedMessageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updatePredefinedMessage', 'uuid', uuid)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePredefinedMessage', 'id', id)
            // verify required parameter 'predefinedMessageRequest' is not null or undefined
            assertParamExists('updatePredefinedMessage', 'predefinedMessageRequest', predefinedMessageRequest)
            const localVarPath = `/tickets/user/{uuid}/predefinedmessages/{id}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(predefinedMessageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTicketAttachment: async (uid: string, fileName: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('uploadTicketAttachment', 'uid', uid)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('uploadTicketAttachment', 'fileName', fileName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadTicketAttachment', 'body', body)
            const localVarPath = `/tickets/{uid}/attachments/{fileName}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTicketMessageAttachment: async (uid: string, messageUuid: string, fileName: string, body: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('uploadTicketMessageAttachment', 'uid', uid)
            // verify required parameter 'messageUuid' is not null or undefined
            assertParamExists('uploadTicketMessageAttachment', 'messageUuid', messageUuid)
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('uploadTicketMessageAttachment', 'fileName', fileName)
            // verify required parameter 'body' is not null or undefined
            assertParamExists('uploadTicketMessageAttachment', 'body', body)
            const localVarPath = `/tickets/{uid}/message/{messageUuid}/attachments/{fileName}`
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)))
                .replace(`{${"messageUuid"}}`, encodeURIComponent(String(messageUuid)))
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TicketsControllerApi - functional programming interface
 * @export
 */
export const TicketsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TicketsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addUserToBlacklist(createBlacklistRecordRequest: CreateBlacklistRecordRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketBlacklist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addUserToBlacklist(createBlacklistRecordRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async closeTicketByUid(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeTicketStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.closeTicketByUid(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPredefinedMessage(uuid: string, predefinedMessageRequest: PredefinedMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PredefinedMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPredefinedMessage(uuid, predefinedMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTicket(createTicketRequest: CreateTicketRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTicket(createTicketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMessage(uid: string, messageUid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMessage(uid, messageUid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePredefinedMessage(uuid: string, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePredefinedMessage(uuid, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async editMessage(uid: string, messageUid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.editMessage(uid, messageUid, sendTicketMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlacklist(page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageTicketBlacklistDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlacklist(page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {HelperStatsRequest} helperStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelperStats(uuid: string, helperStatsRequest: HelperStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HelperStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelperStats(uuid, helperStatsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {HelpersStatsRequest} helpersStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHelpersStats(helpersStatsRequest: HelpersStatsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HelperStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHelpersStats(helpersStatsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPredefinedMessages(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PredefinedMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPredefinedMessages(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRatings(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketRating>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRatings(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketAttachment(uid: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketAttachment(uid, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketByUid(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketByUid(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketMessageAttachment(uid, messageUuid, fileName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTicketTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TicketType>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTicketTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {TicketFilters} [ticketFilters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTickets(page: number, perPage: number, sortBy?: string, sortDirection?: string, ticketFilters?: TicketFilters, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageTicketInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTickets(page, perPage, sortBy, sortDirection, ticketFilters, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserTicketsByUserUuid(uuid: string, page: number, perPage: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageTicketInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserTicketsByUserUuid(uuid, page, perPage, sortBy, sortDirection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isUserBlacklisted(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketBlacklist>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isUserBlacklisted(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postMessage(uid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TicketMessageDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postMessage(uid, sendTicketMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {RateTicketRequest} rateTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rateTicketByUid(uid: string, rateTicketRequest: RateTicketRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rateTicketByUid(uid, rateTicketRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeBlacklistRecord(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeBlacklistRecord(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reopenTicketByUid(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeTicketStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reopenTicketByUid(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rewardCoins(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rewardCoins(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketDuplicate(uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetDuplicateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketDuplicate(uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketHeadRequest} changeTicketHeadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketHead(uid: string, changeTicketHeadRequest: ChangeTicketHeadRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketHead(uid, changeTicketHeadRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetTicketNoteRequest} setTicketNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketNote(uid: string, setTicketNoteRequest: SetTicketNoteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketNote(uid, setTicketNoteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetStarRequest} setStarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketStar(uid: string, setStarRequest: SetStarRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketStar(uid, setStarRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketStateRequest} changeTicketStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setTicketState(uid: string, changeTicketStateRequest: ChangeTicketStateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeTicketStateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setTicketState(uid, changeTicketStateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePredefinedMessage(uuid: string, id: number, predefinedMessageRequest: PredefinedMessageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePredefinedMessage(uuid, id, predefinedMessageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTicketAttachment(uid: string, fileName: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTicketAttachment(uid, fileName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, body: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadTicketMessageAttachment(uid, messageUuid, fileName, body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TicketsControllerApi - factory interface
 * @export
 */
export const TicketsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TicketsControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserToBlacklist(createBlacklistRecordRequest: CreateBlacklistRecordRequest, options?: any): AxiosPromise<TicketBlacklist> {
            return localVarFp.addUserToBlacklist(createBlacklistRecordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeTicketByUid(uid: string, options?: any): AxiosPromise<ChangeTicketStateResponse> {
            return localVarFp.closeTicketByUid(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPredefinedMessage(uuid: string, predefinedMessageRequest: PredefinedMessageRequest, options?: any): AxiosPromise<PredefinedMessage> {
            return localVarFp.createPredefinedMessage(uuid, predefinedMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTicketRequest} createTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTicket(createTicketRequest: CreateTicketRequest, options?: any): AxiosPromise<TicketDTO> {
            return localVarFp.createTicket(createTicketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMessage(uid: string, messageUid: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.deleteMessage(uid, messageUid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePredefinedMessage(uuid: string, id: number, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.deletePredefinedMessage(uuid, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        editMessage(uid: string, messageUid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.editMessage(uid, messageUid, sendTicketMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlacklist(page: number, perPage: number, options?: any): AxiosPromise<ResponsePageTicketBlacklistDTO> {
            return localVarFp.getBlacklist(page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {HelperStatsRequest} helperStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelperStats(uuid: string, helperStatsRequest: HelperStatsRequest, options?: any): AxiosPromise<HelperStats> {
            return localVarFp.getHelperStats(uuid, helperStatsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {HelpersStatsRequest} helpersStatsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHelpersStats(helpersStatsRequest: HelpersStatsRequest, options?: any): AxiosPromise<Array<HelperStats>> {
            return localVarFp.getHelpersStats(helpersStatsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPredefinedMessages(uuid: string, options?: any): AxiosPromise<Array<PredefinedMessage>> {
            return localVarFp.getPredefinedMessages(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRatings(uuid: string, options?: any): AxiosPromise<Array<TicketRating>> {
            return localVarFp.getRatings(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketAttachment(uid: string, fileName: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTicketAttachment(uid, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketByUid(uid: string, options?: any): AxiosPromise<TicketDTO> {
            return localVarFp.getTicketByUid(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getTicketMessageAttachment(uid, messageUuid, fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTicketTypes(options?: any): AxiosPromise<Array<TicketType>> {
            return localVarFp.getTicketTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {TicketFilters} [ticketFilters] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTickets(page: number, perPage: number, sortBy?: string, sortDirection?: string, ticketFilters?: TicketFilters, options?: any): AxiosPromise<ResponsePageTicketInfo> {
            return localVarFp.getTickets(page, perPage, sortBy, sortDirection, ticketFilters, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {string} [sortBy] 
         * @param {string} [sortDirection] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserTicketsByUserUuid(uuid: string, page: number, perPage: number, sortBy?: string, sortDirection?: string, options?: any): AxiosPromise<ResponsePageTicketInfo> {
            return localVarFp.getUserTicketsByUserUuid(uuid, page, perPage, sortBy, sortDirection, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isUserBlacklisted(uuid: string, options?: any): AxiosPromise<TicketBlacklist> {
            return localVarFp.isUserBlacklisted(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {SendTicketMessageRequest} sendTicketMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postMessage(uid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: any): AxiosPromise<TicketMessageDTO> {
            return localVarFp.postMessage(uid, sendTicketMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {RateTicketRequest} rateTicketRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rateTicketByUid(uid: string, rateTicketRequest: RateTicketRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.rateTicketByUid(uid, rateTicketRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {number} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeBlacklistRecord(id: number, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.removeBlacklistRecord(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reopenTicketByUid(uid: string, options?: any): AxiosPromise<ChangeTicketStateResponse> {
            return localVarFp.reopenTicketByUid(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rewardCoins(uid: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.rewardCoins(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketDuplicate(uid: string, options?: any): AxiosPromise<SetDuplicateResponse> {
            return localVarFp.setTicketDuplicate(uid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketHeadRequest} changeTicketHeadRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketHead(uid: string, changeTicketHeadRequest: ChangeTicketHeadRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setTicketHead(uid, changeTicketHeadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetTicketNoteRequest} setTicketNoteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketNote(uid: string, setTicketNoteRequest: SetTicketNoteRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setTicketNote(uid, setTicketNoteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {SetStarRequest} setStarRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketStar(uid: string, setStarRequest: SetStarRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setTicketStar(uid, setStarRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {ChangeTicketStateRequest} changeTicketStateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setTicketState(uid: string, changeTicketStateRequest: ChangeTicketStateRequest, options?: any): AxiosPromise<ChangeTicketStateResponse> {
            return localVarFp.setTicketState(uid, changeTicketStateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} id 
         * @param {PredefinedMessageRequest} predefinedMessageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePredefinedMessage(uuid: string, id: number, predefinedMessageRequest: PredefinedMessageRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.updatePredefinedMessage(uuid, id, predefinedMessageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTicketAttachment(uid: string, fileName: string, body: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.uploadTicketAttachment(uid, fileName, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uid 
         * @param {string} messageUuid 
         * @param {string} fileName 
         * @param {string} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, body: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.uploadTicketMessageAttachment(uid, messageUuid, fileName, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TicketsControllerApi - object-oriented interface
 * @export
 * @class TicketsControllerApi
 * @extends {BaseAPI}
 */
export class TicketsControllerApi extends BaseAPI {
    /**
     * 
     * @param {CreateBlacklistRecordRequest} createBlacklistRecordRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public addUserToBlacklist(createBlacklistRecordRequest: CreateBlacklistRecordRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).addUserToBlacklist(createBlacklistRecordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public closeTicketByUid(uid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).closeTicketByUid(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {PredefinedMessageRequest} predefinedMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public createPredefinedMessage(uuid: string, predefinedMessageRequest: PredefinedMessageRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).createPredefinedMessage(uuid, predefinedMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTicketRequest} createTicketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public createTicket(createTicketRequest: CreateTicketRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).createTicket(createTicketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} messageUid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public deleteMessage(uid: string, messageUid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).deleteMessage(uid, messageUid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public deletePredefinedMessage(uuid: string, id: number, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).deletePredefinedMessage(uuid, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} messageUid 
     * @param {SendTicketMessageRequest} sendTicketMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public editMessage(uid: string, messageUid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).editMessage(uid, messageUid, sendTicketMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getBlacklist(page: number, perPage: number, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getBlacklist(page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {HelperStatsRequest} helperStatsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getHelperStats(uuid: string, helperStatsRequest: HelperStatsRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getHelperStats(uuid, helperStatsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {HelpersStatsRequest} helpersStatsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getHelpersStats(helpersStatsRequest: HelpersStatsRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getHelpersStats(helpersStatsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getPredefinedMessages(uuid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getPredefinedMessages(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getRatings(uuid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getRatings(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getTicketAttachment(uid: string, fileName: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getTicketAttachment(uid, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getTicketByUid(uid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getTicketByUid(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} messageUuid 
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getTicketMessageAttachment(uid, messageUuid, fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getTicketTypes(options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getTicketTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} page 
     * @param {number} perPage 
     * @param {string} [sortBy] 
     * @param {string} [sortDirection] 
     * @param {TicketFilters} [ticketFilters] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getTickets(page: number, perPage: number, sortBy?: string, sortDirection?: string, ticketFilters?: TicketFilters, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getTickets(page, perPage, sortBy, sortDirection, ticketFilters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {string} [sortBy] 
     * @param {string} [sortDirection] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public getUserTicketsByUserUuid(uuid: string, page: number, perPage: number, sortBy?: string, sortDirection?: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).getUserTicketsByUserUuid(uuid, page, perPage, sortBy, sortDirection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public isUserBlacklisted(uuid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).isUserBlacklisted(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {SendTicketMessageRequest} sendTicketMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public postMessage(uid: string, sendTicketMessageRequest: SendTicketMessageRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).postMessage(uid, sendTicketMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {RateTicketRequest} rateTicketRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public rateTicketByUid(uid: string, rateTicketRequest: RateTicketRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).rateTicketByUid(uid, rateTicketRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {number} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public removeBlacklistRecord(id: number, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).removeBlacklistRecord(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public reopenTicketByUid(uid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).reopenTicketByUid(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public rewardCoins(uid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).rewardCoins(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public setTicketDuplicate(uid: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).setTicketDuplicate(uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {ChangeTicketHeadRequest} changeTicketHeadRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public setTicketHead(uid: string, changeTicketHeadRequest: ChangeTicketHeadRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).setTicketHead(uid, changeTicketHeadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {SetTicketNoteRequest} setTicketNoteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public setTicketNote(uid: string, setTicketNoteRequest: SetTicketNoteRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).setTicketNote(uid, setTicketNoteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {SetStarRequest} setStarRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public setTicketStar(uid: string, setStarRequest: SetStarRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).setTicketStar(uid, setStarRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {ChangeTicketStateRequest} changeTicketStateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public setTicketState(uid: string, changeTicketStateRequest: ChangeTicketStateRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).setTicketState(uid, changeTicketStateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} id 
     * @param {PredefinedMessageRequest} predefinedMessageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public updatePredefinedMessage(uuid: string, id: number, predefinedMessageRequest: PredefinedMessageRequest, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).updatePredefinedMessage(uuid, id, predefinedMessageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} fileName 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public uploadTicketAttachment(uid: string, fileName: string, body: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).uploadTicketAttachment(uid, fileName, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uid 
     * @param {string} messageUuid 
     * @param {string} fileName 
     * @param {string} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TicketsControllerApi
     */
    public uploadTicketMessageAttachment(uid: string, messageUuid: string, fileName: string, body: string, options?: AxiosRequestConfig) {
        return TicketsControllerApiFp(this.configuration).uploadTicketMessageAttachment(uid, messageUuid, fileName, body, options).then((request) => request(this.axios, this.basePath));
    }
}
