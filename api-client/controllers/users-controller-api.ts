/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from '../common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
// @ts-ignore
import { ChangeNickRequest } from '../models';
// @ts-ignore
import { ChangeNickResponse } from '../models';
// @ts-ignore
import { GroupDTO } from '../models';
// @ts-ignore
import { MigrateDelayDTO } from '../models';
// @ts-ignore
import { Permission } from '../models';
// @ts-ignore
import { ResponsePageBanRecordDTO } from '../models';
// @ts-ignore
import { ResponsePageCoinsLogDTO } from '../models';
// @ts-ignore
import { ResponsePageCoinsTransactionLogDTO } from '../models';
// @ts-ignore
import { ResponsePageCrateLog } from '../models';
// @ts-ignore
import { ResponsePageMigrateLogDTO } from '../models';
// @ts-ignore
import { ResponsePageMuteRecordDTO } from '../models';
// @ts-ignore
import { ResultResponse } from '../models';
// @ts-ignore
import { SetAgreementRequest } from '../models';
// @ts-ignore
import { SetIPWhitelistRequest } from '../models';
// @ts-ignore
import { SetPremiumRequest } from '../models';
// @ts-ignore
import { UpdateEmailRequest } from '../models';
// @ts-ignore
import { UserInfo } from '../models';
// @ts-ignore
import { UserProfile } from '../models';
// @ts-ignore
import { UserSpecificStats } from '../models';
// @ts-ignore
import { UserStats } from '../models';
/**
 * UsersControllerApi - axios parameter creator
 * @export
 */
export const UsersControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {ChangeNickRequest} changeNickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeNick: async (uuid: string, changeNickRequest: ChangeNickRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('changeNick', 'uuid', uuid)
            // verify required parameter 'changeNickRequest' is not null or undefined
            assertParamExists('changeNick', 'changeNickRequest', changeNickRequest)
            const localVarPath = `/users/{uuid}/changenick`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(changeNickRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteAccount', 'uuid', uuid)
            const localVarPath = `/users/{uuid}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMigrateDelay: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('deleteMigrateDelay', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/migrations/delay`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesUserExist: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('doesUserExist', 'id', id)
            const localVarPath = `/users/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBansByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getBansByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getBansByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getBansByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/bans/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinsLogByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getCoinsLogByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getCoinsLogByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getCoinsLogByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/coins/transactions/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinsTransfersLogByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getCoinsTransfersLogByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getCoinsTransfersLogByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getCoinsTransfersLogByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/coins/transfers/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCratesLogByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getCratesLogByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getCratesLogByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getCratesLogByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/crates/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrateDelay: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getMigrateDelay', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/migrations/delay`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getMigrationsByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getMigrationsByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getMigrationsByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/migrations/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMutesByUUID: async (uuid: string, page: number, perPage: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getMutesByUUID', 'uuid', uuid)
            // verify required parameter 'page' is not null or undefined
            assertParamExists('getMutesByUUID', 'page', page)
            // verify required parameter 'perPage' is not null or undefined
            assertParamExists('getMutesByUUID', 'perPage', perPage)
            const localVarPath = `/users/{uuid}/mutes/{page}/{perPage}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"page"}}`, encodeURIComponent(String(page)))
                .replace(`{${"perPage"}}`, encodeURIComponent(String(perPage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUUID: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getProfileByUUID', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/profile`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsByUuid: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getStatsByUuid', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/stats`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {string} parentMiniGame 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsByUuidAndParentMiniGame: async (uuid: string, parentMiniGame: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getStatsByUuidAndParentMiniGame', 'uuid', uuid)
            // verify required parameter 'parentMiniGame' is not null or undefined
            assertParamExists('getStatsByUuidAndParentMiniGame', 'parentMiniGame', parentMiniGame)
            const localVarPath = `/users/{uuid}/stats/{parentMiniGame}`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)))
                .replace(`{${"parentMiniGame"}}`, encodeURIComponent(String(parentMiniGame)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupByUUID: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getUserGroupByUUID', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/groups`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoBy: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserInfoBy', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByUuid: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('getUserPermissions', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/permissions`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} ip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIP: async (ip: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('getUsersByIP', 'ip', ip)
            const localVarPath = `/users/ip/{ip}`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetAgreementRequest} setAgreementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAgreement: async (uuid: string, setAgreementRequest: SetAgreementRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('setAgreement', 'uuid', uuid)
            // verify required parameter 'setAgreementRequest' is not null or undefined
            assertParamExists('setAgreement', 'setAgreementRequest', setAgreementRequest)
            const localVarPath = `/users/{uuid}/agreement`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setAgreementRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetIPWhitelistRequest} setIPWhitelistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIPWhitelist: async (uuid: string, setIPWhitelistRequest: SetIPWhitelistRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('setIPWhitelist', 'uuid', uuid)
            // verify required parameter 'setIPWhitelistRequest' is not null or undefined
            assertParamExists('setIPWhitelist', 'setIPWhitelistRequest', setIPWhitelistRequest)
            const localVarPath = `/users/{uuid}/ipwhitelist`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setIPWhitelistRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMigrateDelay: async (uuid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('setMigrateDelay', 'uuid', uuid)
            const localVarPath = `/users/{uuid}/migrations/delay`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetPremiumRequest} setPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPremium: async (uuid: string, setPremiumRequest: SetPremiumRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('setPremium', 'uuid', uuid)
            // verify required parameter 'setPremiumRequest' is not null or undefined
            assertParamExists('setPremium', 'setPremiumRequest', setPremiumRequest)
            const localVarPath = `/users/{uuid}/premium`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(setPremiumRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail: async (uuid: string, updateEmailRequest: UpdateEmailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateEmail', 'uuid', uuid)
            // verify required parameter 'updateEmailRequest' is not null or undefined
            assertParamExists('updateEmail', 'updateEmailRequest', updateEmailRequest)
            const localVarPath = `/users/{uuid}/email`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersControllerApi - functional programming interface
 * @export
 */
export const UsersControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {ChangeNickRequest} changeNickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeNick(uuid: string, changeNickRequest: ChangeNickRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChangeNickResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeNick(uuid, changeNickRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMigrateDelay(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMigrateDelay(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doesUserExist(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doesUserExist(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBansByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageBanRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBansByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoinsLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageCoinsLogDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoinsLogByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCoinsTransfersLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageCoinsTransactionLogDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCoinsTransfersLogByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCratesLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageCrateLog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCratesLogByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrateDelay(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrateDelayDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrateDelay(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMigrationsByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageMigrateLogDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMigrationsByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMutesByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponsePageMuteRecordDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMutesByUUID(uuid, page, perPage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProfileByUUID(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserProfile>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProfileByUUID(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatsByUuid(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsByUuid(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {string} parentMiniGame 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatsByUuidAndParentMiniGame(uuid: string, parentMiniGame: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSpecificStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatsByUuidAndParentMiniGame(uuid, parentMiniGame, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserGroupByUUID(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<GroupDTO>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserGroupByUUID(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoBy(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoBy(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoByUuid(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoByUuid(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPermissions(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Permission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPermissions(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} ip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsersByIP(ip: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserProfile>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsersByIP(ip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetAgreementRequest} setAgreementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAgreement(uuid: string, setAgreementRequest: SetAgreementRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAgreement(uuid, setAgreementRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetIPWhitelistRequest} setIPWhitelistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setIPWhitelist(uuid: string, setIPWhitelistRequest: SetIPWhitelistRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setIPWhitelist(uuid, setIPWhitelistRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setMigrateDelay(uuid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MigrateDelayDTO>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setMigrateDelay(uuid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetPremiumRequest} setPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setPremium(uuid: string, setPremiumRequest: SetPremiumRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setPremium(uuid, setPremiumRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmail(uuid: string, updateEmailRequest: UpdateEmailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmail(uuid, updateEmailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersControllerApi - factory interface
 * @export
 */
export const UsersControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} uuid 
         * @param {ChangeNickRequest} changeNickRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeNick(uuid: string, changeNickRequest: ChangeNickRequest, options?: any): AxiosPromise<ChangeNickResponse> {
            return localVarFp.changeNick(uuid, changeNickRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(uuid: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.deleteAccount(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMigrateDelay(uuid: string, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.deleteMigrateDelay(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doesUserExist(id: string, options?: any): AxiosPromise<boolean> {
            return localVarFp.doesUserExist(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBansByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageBanRecordDTO> {
            return localVarFp.getBansByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinsLogByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageCoinsLogDTO> {
            return localVarFp.getCoinsLogByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCoinsTransfersLogByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageCoinsTransactionLogDTO> {
            return localVarFp.getCoinsTransfersLogByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCratesLogByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageCrateLog> {
            return localVarFp.getCratesLogByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrateDelay(uuid: string, options?: any): AxiosPromise<MigrateDelayDTO> {
            return localVarFp.getMigrateDelay(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMigrationsByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageMigrateLogDTO> {
            return localVarFp.getMigrationsByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {number} page 
         * @param {number} perPage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMutesByUUID(uuid: string, page: number, perPage: number, options?: any): AxiosPromise<ResponsePageMuteRecordDTO> {
            return localVarFp.getMutesByUUID(uuid, page, perPage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProfileByUUID(uuid: string, options?: any): AxiosPromise<UserProfile> {
            return localVarFp.getProfileByUUID(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsByUuid(uuid: string, options?: any): AxiosPromise<UserStats> {
            return localVarFp.getStatsByUuid(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {string} parentMiniGame 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatsByUuidAndParentMiniGame(uuid: string, parentMiniGame: string, options?: any): AxiosPromise<UserSpecificStats> {
            return localVarFp.getStatsByUuidAndParentMiniGame(uuid, parentMiniGame, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserGroupByUUID(uuid: string, options?: any): AxiosPromise<Set<GroupDTO>> {
            return localVarFp.getUserGroupByUUID(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoBy(id: string, options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getUserInfoBy(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoByUuid(options?: any): AxiosPromise<UserInfo> {
            return localVarFp.getUserInfoByUuid(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPermissions(uuid: string, options?: any): AxiosPromise<Set<Permission>> {
            return localVarFp.getUserPermissions(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} ip 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsersByIP(ip: string, options?: any): AxiosPromise<Array<UserProfile>> {
            return localVarFp.getUsersByIP(ip, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetAgreementRequest} setAgreementRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAgreement(uuid: string, setAgreementRequest: SetAgreementRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setAgreement(uuid, setAgreementRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetIPWhitelistRequest} setIPWhitelistRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setIPWhitelist(uuid: string, setIPWhitelistRequest: SetIPWhitelistRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setIPWhitelist(uuid, setIPWhitelistRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setMigrateDelay(uuid: string, options?: any): AxiosPromise<MigrateDelayDTO> {
            return localVarFp.setMigrateDelay(uuid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {SetPremiumRequest} setPremiumRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setPremium(uuid: string, setPremiumRequest: SetPremiumRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.setPremium(uuid, setPremiumRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} uuid 
         * @param {UpdateEmailRequest} updateEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail(uuid: string, updateEmailRequest: UpdateEmailRequest, options?: any): AxiosPromise<ResultResponse> {
            return localVarFp.updateEmail(uuid, updateEmailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersControllerApi - object-oriented interface
 * @export
 * @class UsersControllerApi
 * @extends {BaseAPI}
 */
export class UsersControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} uuid 
     * @param {ChangeNickRequest} changeNickRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public changeNick(uuid: string, changeNickRequest: ChangeNickRequest, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).changeNick(uuid, changeNickRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public deleteAccount(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).deleteAccount(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public deleteMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).deleteMigrateDelay(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public doesUserExist(id: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).doesUserExist(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getBansByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getBansByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getCoinsLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getCoinsLogByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getCoinsTransfersLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getCoinsTransfersLogByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getCratesLogByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getCratesLogByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getMigrateDelay(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getMigrationsByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getMigrationsByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {number} page 
     * @param {number} perPage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getMutesByUUID(uuid: string, page: number, perPage: number, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getMutesByUUID(uuid, page, perPage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getProfileByUUID(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getProfileByUUID(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getStatsByUuid(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getStatsByUuid(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {string} parentMiniGame 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getStatsByUuidAndParentMiniGame(uuid: string, parentMiniGame: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getStatsByUuidAndParentMiniGame(uuid, parentMiniGame, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUserGroupByUUID(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getUserGroupByUUID(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUserInfoBy(id: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getUserInfoBy(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUserInfoByUuid(options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getUserInfoByUuid(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUserPermissions(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getUserPermissions(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} ip 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public getUsersByIP(ip: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).getUsersByIP(ip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {SetAgreementRequest} setAgreementRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public setAgreement(uuid: string, setAgreementRequest: SetAgreementRequest, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).setAgreement(uuid, setAgreementRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {SetIPWhitelistRequest} setIPWhitelistRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public setIPWhitelist(uuid: string, setIPWhitelistRequest: SetIPWhitelistRequest, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).setIPWhitelist(uuid, setIPWhitelistRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public setMigrateDelay(uuid: string, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).setMigrateDelay(uuid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {SetPremiumRequest} setPremiumRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public setPremium(uuid: string, setPremiumRequest: SetPremiumRequest, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).setPremium(uuid, setPremiumRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} uuid 
     * @param {UpdateEmailRequest} updateEmailRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersControllerApi
     */
    public updateEmail(uuid: string, updateEmailRequest: UpdateEmailRequest, options?: AxiosRequestConfig) {
        return UsersControllerApiFp(this.configuration).updateEmail(uuid, updateEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
